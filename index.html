<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultimate Tic Tac Toe (Online 2-player)</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #171a2b;
      --grid: #2b2f49;
      --text: #e8eaf6;
      --muted: #a9add1;
      --x: #7ee787;
      --o: #ff7b72;
      --warn: #ffd166;
      --shadow: rgba(0,0,0,.35);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 20% 10%, #1b1f39, var(--bg));
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100vh;
      padding: 18px;
    }
    .wrap { width: min(980px, 98vw); display: grid; gap: 14px; }
    .topbar {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 12px 30px var(--shadow);
      display: grid;
      gap: 10px;
    }
    .title { font-weight: 800; letter-spacing: .3px; font-size: 18px; margin: 0; }
    .status { margin: 0; color: var(--muted); line-height: 1.35; }
    .status b { color: var(--text); }

    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .box {
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    input {
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      color: var(--text);
      padding: 10px 12px;
      min-width: 220px;
      outline: none;
    }
    button.ctrl {
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
    }
    button.ctrl:hover { background: rgba(255,255,255,.09); }
    .hint { font-size: 13px; color: var(--muted); }

    .big {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 12px 30px var(--shadow);
    }
    .bigGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }

    .small {
      position: relative;
      background: rgba(0,0,0,.15);
      border: 2px solid var(--grid);
      border-radius: 12px;
      padding: 10px;
      transition: transform .08s ease, border-color .12s ease, box-shadow .12s ease;
      user-select: none;
    }
    .small.active {
      border-color: rgba(255, 209, 102, .95);
      box-shadow: 0 0 0 3px rgba(255, 209, 102, .15);
      transform: translateY(-1px);
    }
    .small.free .badge {
      background: rgba(255, 209, 102, .15);
      border: 1px solid rgba(255, 209, 102, .35);
      color: var(--warn);
    }
    .badge {
      position: absolute;
      top: 8px;
      left: 8px;
      font-size: 12px;
      padding: 4px 7px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
    }
    .smallGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 18px; }
    .cell {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-size: clamp(18px, 2.6vw, 28px);
      font-weight: 900;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
    }
    .cell:hover { background: rgba(255,255,255,.08); transform: translateY(-1px); }
    .cell:disabled { cursor: not-allowed; opacity: .65; transform: none; }
    .cell.x { color: var(--x); }
    .cell.o { color: var(--o); }

    .overlay {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-weight: 1000;
      font-size: clamp(32px, 5vw, 58px);
      letter-spacing: 1px;
      background: rgba(0,0,0,.35);
      border: 2px solid rgba(255,255,255,.08);
      pointer-events: none;
      opacity: 0;
      transition: opacity .15s ease;
    }
    .overlay.show { opacity: 1; }
    .overlay.x { color: var(--x); }
    .overlay.o { color: var(--o); }
    .overlay.t { color: var(--muted); font-size: clamp(20px, 3.2vw, 34px); font-weight: 900; }

    .footer { color: var(--muted); font-size: 12px; text-align: center; padding-bottom: 4px; }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 class="title">Ultimate Tic Tac Toe (online two-player)</h1>

      <div class="row">
        <div class="box">
          <button class="ctrl" id="createRoomBtn" type="button">Lag rom</button>
          <input id="roomInput" placeholder="Romkode (f.eks. ABCD)" maxlength="12" />
          <button class="ctrl" id="joinRoomBtn" type="button">Bli med</button>
          <button class="ctrl" id="copyLinkBtn" type="button">Kopier link</button>
          <span class="pill" id="roomPill">Ikke tilkoblet</span>
          <span class="pill" id="rolePill">Rolle: -</span>
        </div>
      </div>

      <p class="status" id="status"></p>
      <div class="row">
        <button class="ctrl" id="resetBtn" type="button">Nullstill (ny runde i samme rom)</button>
        <span class="hint">Tips: Send linken til en venn. Første som joiner blir X, neste blir O.</span>
      </div>

      <!-- Bot options row: Velg vanskelighetsgrad for å spille mot en enkel datamaskin. -->
      <div class="row" id="botOptionsRow">
        <span class="pill">Spill mot bot:</span>
        <button class="ctrl" id="botEasyBtn" type="button">Lett</button>
        <button class="ctrl" id="botMediumBtn" type="button">Middels</button>
        <button class="ctrl" id="botHardBtn" type="button">Vanskelig</button>
      </div>
    </div>

    <div class="big">
      <div class="bigGrid" id="bigGrid"></div>
    </div>

    <div class="footer">
      Krever hosting (GitHub Pages) + Firebase Firestore for live synk.
    </div>
  </div>

  <!-- Firebase (modular SDK) -->
  <script type="module">
    // Flattener helpers
    function flattenBoards(boards) {
      return boards.flat();
    }

    function unflattenBoards(flat) {
      const out = [];
      for (let i = 0; i < 9; i++) {
        out.push(flat.slice(i * 9, i * 9 + 9));
      }
      return out;
    }

    // Firebase config (your own)
    const firebaseConfig = {
      apiKey: "AIzaSyCV0TRPv09RaAnYQP7jE43olIr_O77Iwm8",
      authDomain: "ultimate-tic-tac-toe-4bf73.firebaseapp.com",
      projectId: "ultimate-tic-tac-toe-4bf73",
      storageBucket: "ultimate-tic-tac-toe-4bf73.firebasestorage.app",
      messagingSenderId: "920364547136",
      appId: "1:920364547136:web:212997dc55347d64be33a5",
      measurementId: "G-65WQJKMEQB"
    };

    // === Importer Firebase ===
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // === UI refs ===
    const bigGridEl = document.getElementById("bigGrid");
    const statusEl = document.getElementById("status");
    const resetBtn = document.getElementById("resetBtn");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const roomInput = document.getElementById("roomInput");
    const roomPill = document.getElementById("roomPill");
    const rolePill = document.getElementById("rolePill");

    // Bot UI references
    const botEasyBtn = document.getElementById("botEasyBtn");
    const botMediumBtn = document.getElementById("botMediumBtn");
    const botHardBtn = document.getElementById("botHardBtn");

    // === Game state (lokalt speil av rommet) ===
    let roomId = null;
    let myUid = null;
    let myRole = null; // 'X' or 'O'
    let unsub = null;

    // data:
    let moveHistory; // liste med alle trekk
    let boards;
    let smallWinners;
    let currentPlayer;
    let activeBoard;
    let gameOver;

    // Spill mot bot: statusvariabler
    let vsBot = false;
    let botDifficulty = null;

    // === Helpers ===
    function randRoomCode(len = 4) {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out = "";
      for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
      return out;
    }

    function setStatus(html) { statusEl.innerHTML = html; }

    function emptyState() {
      boards = Array.from({ length: 9 }, () => Array(9).fill(""));
      smallWinners = Array(9).fill("");
      currentPlayer = "X";
      activeBoard = -1;
      gameOver = false;
      moveHistory = [];
    }

    function isBoardFinished(b) { return smallWinners[b] !== ""; }

    function checkWin3x3(arr) {
      const lines = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6]
      ];
      for (const [a,b,c] of lines) {
        if (arr[a] && arr[a] === arr[b] && arr[a] === arr[c]) return arr[a];
      }
      return "";
    }
    function checkTie3x3(arr) { return arr.every(v => v === "X" || v === "O"); }
    function getBigBoardAs3x3() {
      return smallWinners.map(w => (w === "X" || w === "O") ? w : "");
    }
    function checkBigWin() { return checkWin3x3(getBigBoardAs3x3()); }

    function cellClass(v) {
      if (v === "X") return "cell x";
      if (v === "O") return "cell o";
      return "cell";
    }

    // === Bot helpers and game mode ===
    /**
     * Return a list of small board indices (0-8) where a move can be made.
     * Hvis activeBoard er angitt og ikke ferdig, må neste trekk spilles der.
     */
    function getAllowedBoards() {
      if (activeBoard !== -1 && !isBoardFinished(activeBoard)) {
        return [activeBoard];
      }
      const res = [];
      for (let i = 0; i < 9; i++) {
        if (!isBoardFinished(i)) res.push(i);
      }
      return res;
    }

    /**
     * Return a list of available cell indices (0-8) in a given small board.
     */
    function getAvailableCells(b) {
      const cells = [];
      for (let i = 0; i < 9; i++) {
        if (!boards[b][i]) cells.push(i);
      }
      return cells;
    }

    /**
     * Check if placing `mark` in a small board can create a win on this move.
     * Returns the cell index that completes a winning line, or -1 if none.
     */
    function findWinningCell(cellsArr, mark) {
      const lines = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6]
      ];
      for (const [a,b,c] of lines) {
        const va = cellsArr[a], vb = cellsArr[b], vc = cellsArr[c];
        if (va === mark && vb === mark && !vc) return c;
        if (va === mark && vc === mark && !vb) return b;
        if (vb === mark && vc === mark && !va) return a;
      }
      return -1;
    }

    /**
     * Find a blocking move against the opponent's mark (returns cell index or -1).
     */
    function findBlockingCell(cellsArr, opponentMark) {
      return findWinningCell(cellsArr, opponentMark);
    }

    /**
     * Let the bot (always 'O') make a move based on the chosen difficulty.
     * This updates the global game state and does not interact with Firestore.
     */
    function performBotMove() {
      if (!vsBot || gameOver) return;
      // Bot mark and opponent mark
      const allowedBoards = getAllowedBoards();
      let chosenBoard = null;
      let chosenCell = null;

      // Step 1 & 2: Try to win or block only for medium/hard difficulty.
      if (botDifficulty === "medium" || botDifficulty === "hard") {
        // Step 1: Look for a winning move for bot
        for (const b of allowedBoards) {
          const boardCells = boards[b];
          const winCell = findWinningCell(boardCells, "O");
          if (winCell >= 0) {
            chosenBoard = b;
            chosenCell = winCell;
            break;
          }
        }

        // Step 2: Block the opponent's winning move
        if (chosenBoard === null) {
          for (const b of allowedBoards) {
            const boardCells = boards[b];
            const blockCell = findBlockingCell(boardCells, "X");
            if (blockCell >= 0) {
              chosenBoard = b;
              chosenCell = blockCell;
              break;
            }
          }
        }
      }

      // Step 3: Additional heuristics for hard difficulty (center first, then corners)
      if (chosenBoard === null && botDifficulty === "hard") {
        // Try center of allowed boards
        for (const b of allowedBoards) {
          const boardCells = boards[b];
          if (!boardCells[4]) {
            chosenBoard = b;
            chosenCell = 4;
            break;
          }
        }
        // Try corners if no center available
        const corners = [0, 2, 6, 8];
        if (chosenBoard === null) {
          outer: for (const b of allowedBoards) {
            const boardCells = boards[b];
            for (const corner of corners) {
              if (!boardCells[corner]) {
                chosenBoard = b;
                chosenCell = corner;
                break outer;
              }
            }
          }
        }
      }

      // Step 4: fallback random move
      if (chosenBoard === null) {
        const bIndex = Math.floor(Math.random() * allowedBoards.length);
        chosenBoard = allowedBoards[bIndex];
        const availableCells = getAvailableCells(chosenBoard);
        const cIndex = Math.floor(Math.random() * availableCells.length);
        chosenCell = availableCells[cIndex];
      }

      // Apply the chosen move
      const b = chosenBoard;
      const c = chosenCell;
      // Record in history
      const moveNumber = (moveHistory?.length || 0) + 1;
      moveHistory = [...(moveHistory || []), { p: "O", b, c, n: moveNumber }];
      boards[b][c] = "O";

      // Update small board result
      const smallWin = checkWin3x3(boards[b]);
      if (smallWin) smallWinners[b] = smallWin;
      else if (checkTie3x3(boards[b])) smallWinners[b] = "T";

      // Check big board
      const bigWin = checkBigWin();
      if (bigWin) {
        gameOver = true;
      } else {
        activeBoard = c;
        if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;
        currentPlayer = "X";
      }
    }

    /**
     * Start a game versus the bot. Human is always 'X' and bot is 'O'.
     * @param {string} level "easy" | "medium" | "hard"
     */
    function startBotGame(level) {
      vsBot = true;
      botDifficulty = level;
      // Unsubscribe from any Firestore listeners
      if (unsub) { unsub(); unsub = null; }
      roomId = null;
      myRole = null;
      // Update pills to indicate bot play
      roomPill.textContent = "Bot";
      rolePill.textContent = "Du (X) vs Bot (O)";
      emptyState();
      buildUI();
      updateUI();
    }

    function buildUI() {
      bigGridEl.innerHTML = "";
      for (let b = 0; b < 9; b++) {
        const small = document.createElement("div");
        small.className = "small";
        small.dataset.board = String(b);

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = `Spill ${b + 1}`;
        small.appendChild(badge);

        const grid = document.createElement("div");
        grid.className = "smallGrid";

        for (let c = 0; c < 9; c++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "cell";
          btn.dataset.board = String(b);
          btn.dataset.cell = String(c);
          btn.addEventListener("click", onCellClick);
          grid.appendChild(btn);
        }

        small.appendChild(grid);

        const overlay = document.createElement("div");
        overlay.className = "overlay";
        overlay.dataset.overlay = String(b);
        small.appendChild(overlay);

        bigGridEl.appendChild(small);
      }
    }

    function updateUI() {
      // Hvis vi spiller mot bot
      if (vsBot) {
        // Hvis activeBoard peker på ferdig småspill => fri
        if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;
        const smallEls = bigGridEl.querySelectorAll(".small");
        smallEls.forEach(small => {
          const b = Number(small.dataset.board);
          small.classList.remove("active", "free");
          if (activeBoard === -1) {
            if (!isBoardFinished(b)) small.classList.add("active", "free");
          } else {
            if (b === activeBoard) small.classList.add("active");
          }
          const btns = small.querySelectorAll(".cell");
          btns.forEach(btn => {
            const c = Number(btn.dataset.cell);
            const v = boards[b][c];
            btn.textContent = v;
            btn.className = cellClass(v);
            // disable hvis: spill over, opptatt, småspill ferdig, feil aktivt brett eller det er bot sin tur
            let disabled = false;
            if (gameOver) disabled = true;
            if (v) disabled = true;
            if (isBoardFinished(b)) disabled = true;
            const allowedByActive =
              (activeBoard === -1) ? (!isBoardFinished(b)) : (b === activeBoard);
            if (!allowedByActive) disabled = true;
            if (currentPlayer === "O") disabled = true;
            btn.disabled = disabled;
          });
          // overlay
          const overlay = small.querySelector(".overlay");
          const w = smallWinners[b];
          overlay.classList.remove("show", "x", "o", "t");
          overlay.textContent = "";
          if (w === "X" || w === "O") {
            overlay.classList.add("show", w.toLowerCase());
            overlay.textContent = w;
          } else if (w === "T") {
            overlay.classList.add("show", "t");
            overlay.textContent = "Uavgjort";
          }
        });
        // statusmeldinger for bot-spill
        if (gameOver) {
          const win = checkBigWin();
          if (win === "X") {
            setStatus(`Spillet er ferdig. Du (X) vant!`);
          } else if (win === "O") {
            setStatus(`Spillet er ferdig. Bot (O) vant.`);
          } else {
            setStatus(`Spillet endte uavgjort.`);
          }
        } else {
          const nextInfo = (activeBoard === -1)
            ? "Neste trekk: <b>fri plassering</b> i et småspill som ikke er ferdig."
            : `Neste trekk må spilles i småspill <b>${activeBoard + 1}</b>.`;
          if (currentPlayer === "X") {
            setStatus(`Din tur (X). ${nextInfo}`);
          } else {
            setStatus(`Bot sin tur (O). ${nextInfo}`);
          }
        }
        return;
      }
      // Normal (online) modus
      // Hvis activeBoard peker på ferdig småspill => fri
      if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;
      // Oppdater brettet
      const smallEls = bigGridEl.querySelectorAll(".small");
      smallEls.forEach(small => {
        const b = Number(small.dataset.board);
        small.classList.remove("active", "free");
        if (activeBoard === -1) {
          if (!isBoardFinished(b)) small.classList.add("active", "free");
        } else {
          if (b === activeBoard) small.classList.add("active");
        }
        const btns = small.querySelectorAll(".cell");
        btns.forEach(btn => {
          const c = Number(btn.dataset.cell);
          const v = boards[b][c];
          btn.textContent = v;
          btn.className = cellClass(v);
          // disable hvis: ikke i rom, gameOver, tatt, småspill ferdig, ikke din tur, eller feil aktivt brett
          let disabled = false;
          if (!roomId || !myRole) disabled = true;
          if (gameOver) disabled = true;
          if (v) disabled = true;
          if (isBoardFinished(b)) disabled = true;
          const allowedByActive =
            (activeBoard === -1) ? (!isBoardFinished(b)) : (b === activeBoard);
          if (!allowedByActive) disabled = true;
          if (myRole !== currentPlayer) disabled = true;
          btn.disabled = disabled;
        });
        // overlay
        const overlay = small.querySelector(".overlay");
        const w = smallWinners[b];
        overlay.classList.remove("show", "x", "o", "t");
        overlay.textContent = "";
        if (w === "X" || w === "O") {
          overlay.classList.add("show", w.toLowerCase());
          overlay.textContent = w;
        } else if (w === "T") {
          overlay.classList.add("show", "t");
          overlay.textContent = "Uavgjort";
        }
      });
      // status
      if (!roomId) {
        setStatus(`Ikke tilkoblet. Trykk <b>Lag rom</b> eller <b>Bli med</b>.`);
        return;
      }
      if (!myRole) {
        setStatus(`Koblet til rom <b>${roomId}</b>. Venter på rolle...`);
        return;
      }
      const pSpan = (currentPlayer === "X")
        ? `<b style="color: var(--x)">X</b>`
        : `<b style="color: var(--o)">O</b>`;
      const meSpan = (myRole === "X")
        ? `<b style="color: var(--x)">X</b>`
        : `<b style="color: var(--o)">O</b>`;
      const nextInfo = (activeBoard === -1)
        ? "Neste trekk: <b>fri plassering</b> i et småspill som ikke er ferdig."
        : `Neste trekk må spilles i småspill <b>${activeBoard + 1}</b>.`;
      if (gameOver) {
        const win = checkBigWin();
        setStatus(`Spillet er ferdig. Vinner: <b>${win}</b>. (Du er ${meSpan})`);
      } else {
        const turnTxt = (myRole === currentPlayer)
          ? `Din tur (${meSpan}).`
          : `Motstander sin tur. (Du er ${meSpan})`;
        setStatus(`${turnTxt} Tur: ${pSpan}. ${nextInfo}`);
      }
    }

    // === Firebase setup ===
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    await signInAnonymously(auth);

    onAuthStateChanged(auth, (user) => {
      if (!user) return;
      myUid = user.uid;
      // auto-join via ?room=
      const params = new URLSearchParams(location.search);
      const qRoom = (params.get("room") || "").trim().toUpperCase();
      if (qRoom) {
        roomInput.value = qRoom;
        joinRoom(qRoom);
      }
    });

    function roomRef(id) { return doc(db, "rooms", id); }

    async function createRoom() {
      const id = randRoomCode(4);
      roomId = id;

      emptyState();
      const payload = {
        createdAt: serverTimestamp(),
        players: { x: myUid, o: null },
        state: {
          boards: flattenBoards(boards),
          smallWinners,
          currentPlayer,
          activeBoard,
          gameOver,
          move: 0,
          moveHistory: []
        }
      };
      await setDoc(roomRef(id), payload);
      await attachRoom(id);
      updateUrl(id);
      await claimRoleIfNeeded(); // should become X
    }

    async function joinRoom(id) {
      roomId = id;
      const snap = await getDoc(roomRef(id));
      if (!snap.exists()) {
        alert("Fant ikke rom. Sjekk koden.");
        roomId = null;
        return;
      }
      await attachRoom(id);
      updateUrl(id);
      await claimRoleIfNeeded();
    }

    function updateUrl(id) {
      const url = new URL(location.href);
      url.searchParams.set("room", id);
      history.replaceState({}, "", url.toString());
      roomPill.textContent = `Rom: ${id}`;
    }

    async function attachRoom(id) {
      if (unsub) unsub();
      roomPill.textContent = `Rom: ${id}`;

      unsub = onSnapshot(roomRef(id), (snap) => {
        const data = snap.data();
        if (!data) return;

        // role
        const px = data.players?.x || null;
        const po = data.players?.o || null;
        myRole = (myUid === px) ? "X" : (myUid === po) ? "O" : null;
        rolePill.textContent = `Rolle: ${myRole || "Spectator"}`;

        // state
        const st = data.state;
        if (st) {
          boards = unflattenBoards(st.boards);
          smallWinners = st.smallWinners;
          currentPlayer = st.currentPlayer;
          activeBoard = st.activeBoard;
          gameOver = st.gameOver;
          moveHistory = st.moveHistory || [];
        }

        updateUI();
      });
    }

    async function claimRoleIfNeeded() {
      if (!roomId) return;
      const ref = roomRef(roomId);
      const snap = await getDoc(ref);
      if (!snap.exists()) return;

      const data = snap.data();
      const px = data.players?.x || null;
      const po = data.players?.o || null;

      // If I'm already a player, done
      if (myUid === px || myUid === po) return;

      // Claim O if empty, else spectator
      if (!px) {
        await updateDoc(ref, { "players.x": myUid });
      } else if (!po) {
        await updateDoc(ref, { "players.o": myUid });
      } else {
        // already full
      }
    }

    // === Gameplay (writes to Firestore) ===
    async function onCellClick(e) {
      // Hvis vi spiller mot bot
      if (vsBot) {
        if (gameOver) return;
        // Bare la spilleren (X) gjøre trekk
        if (currentPlayer !== "X") return;
        const btn = e.currentTarget;
        const b = Number(btn.dataset.board);
        const c = Number(btn.dataset.cell);
        // enforce active board
        if (activeBoard !== -1 && b !== activeBoard) return;
        if (isBoardFinished(b)) return;
        if (boards[b][c]) return;
        // record move
        const moveNumber = (moveHistory?.length || 0) + 1;
        moveHistory = [...(moveHistory || []), { p: "X", b, c, n: moveNumber }];
        boards[b][c] = "X";
        const smallWin = checkWin3x3(boards[b]);
        if (smallWin) smallWinners[b] = smallWin;
        else if (checkTie3x3(boards[b])) smallWinners[b] = "T";
        const bigWin = checkBigWin();
        if (bigWin) {
          gameOver = true;
        } else {
          activeBoard = c;
          if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;
          currentPlayer = "O";
        }
        updateUI();
        // Bot trekker hvis spillet ikke er ferdig
        if (!gameOver) {
          // Gi en liten forsinkelse så brukeren ser trekket sitt
          setTimeout(() => {
            performBotMove();
            updateUI();
          }, 200);
        }
        return;
      }
      // Online modus
      if (!roomId || !myRole) return;
      if (gameOver) return;
      if (myRole !== currentPlayer) return;
      const btn = e.currentTarget;
      const b = Number(btn.dataset.board);
      const c = Number(btn.dataset.cell);
      const moveNumber = (moveHistory?.length || 0) + 1;
      const newMove = { p: currentPlayer, b, c, n: moveNumber };
      moveHistory = [...(moveHistory || []), newMove];
      // enforce active board
      if (activeBoard !== -1 && b !== activeBoard) return;
      if (isBoardFinished(b)) return;
      if (boards[b][c]) return;
      // apply move locally
      boards[b][c] = currentPlayer;
      const smallWin = checkWin3x3(boards[b]);
      if (smallWin) smallWinners[b] = smallWin;
      else if (checkTie3x3(boards[b])) smallWinners[b] = "T";
      const bigWin = checkBigWin();
      if (bigWin) {
        gameOver = true;
      } else {
        activeBoard = c;
        if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;
        currentPlayer = (currentPlayer === "X") ? "O" : "X";
      }
      // push to firestore
      const ref = roomRef(roomId);
      await updateDoc(ref, {
        "state.boards": flattenBoards(boards),
        "state.smallWinners": smallWinners,
        "state.currentPlayer": currentPlayer,
        "state.activeBoard": activeBoard,
        "state.gameOver": gameOver,
        "state.moveHistory": moveHistory,
        "state.move": (Number((await getDoc(ref)).data()?.state?.move || 0) + 1)
      });
    }

    async function resetRoundSameRoom() {
      // Hvis vi spiller mot bot: start en ny runde lokalt uten å kontakte Firestore
      if (vsBot) {
        emptyState();
        buildUI();
        updateUI();
        return;
      }
      if (!roomId) return;
      emptyState();
      await updateDoc(roomRef(roomId), {
        "state.boards": flattenBoards(boards),
        "state.smallWinners": smallWinners,
        "state.currentPlayer": currentPlayer,
        "state.activeBoard": activeBoard,
        "state.gameOver": gameOver,
        "state.moveHistory": [],
        "state.move": 0
      });
    }

    // === Buttons ===
    createRoomBtn.addEventListener("click", async () => {
      // Ikke lag rom når du spiller mot bot
      if (vsBot) {
        alert("Avslutt bot-spill for å lage et nytt rom.");
        return;
      }
      try { await createRoom(); }
      catch (err) { alert("Feil ved oppretting. Har du limt inn firebaseConfig?"); console.error(err); }
    });

    joinRoomBtn.addEventListener("click", async () => {
      // Ikke bli med i rom når du spiller mot bot
      if (vsBot) {
        alert("Avslutt bot-spill for å bli med i et rom.");
        return;
      }
      const id = (roomInput.value || "").trim().toUpperCase();
      if (!id) return alert("Skriv inn romkode.");
      try { await joinRoom(id); }
      catch (err) { alert("Feil ved joining."); console.error(err); }
    });

    copyLinkBtn.addEventListener("click", async () => {
      // I bot-modus finnes det ingen lenke
      if (vsBot) {
        alert("Det finnes ingen link i bot-modus.");
        return;
      }
      if (!roomId) return alert("Lag/join et rom først.");
      const url = new URL(location.href);
      url.searchParams.set("room", roomId);
      try {
        await navigator.clipboard.writeText(url.toString());
        alert("Link kopiert!");
      } catch {
        prompt("Kopier denne linken:", url.toString());
      }
    });

    resetBtn.addEventListener("click", resetRoundSameRoom);

    // Bot-knapper: start et lokalt spill mot datamaskinen
    botEasyBtn.addEventListener("click", () => {
      startBotGame("easy");
    });
    botMediumBtn.addEventListener("click", () => {
      startBotGame("medium");
    });
    botHardBtn.addEventListener("click", () => {
      startBotGame("hard");
    });

    // init UI
    emptyState();
    buildUI();
    updateUI();
  </script>
</body>
</html>
