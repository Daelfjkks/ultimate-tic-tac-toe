<!doctype html>
<html lang="no">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ultimate Tic Tac Toe (Online 2-player)</title>
  <style>
    :root {
      --bg: #0f1220;
      --panel: #171a2b;
      --grid: #2b2f49;
      --text: #e8eaf6;
      --muted: #a9add1;
      --x: #7ee787;
      --o: #ff7b72;
      --warn: #ffd166;
      --shadow: rgba(0,0,0,.35);
      --radius: 14px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 700px at 20% 10%, #1b1f39, var(--bg));
      color: var(--text);
      display: grid;
      place-items: center;
      min-height: 100vh;
      padding: 18px;
    }
    .wrap { width: min(980px, 98vw); display: grid; gap: 14px; }
    .topbar {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 14px 14px;
      box-shadow: 0 12px 30px var(--shadow);
      display: grid;
      gap: 10px;
    }
    .title { font-weight: 800; letter-spacing: .3px; font-size: 18px; margin: 0; }
    .status { margin: 0; color: var(--muted); line-height: 1.35; }
    .status b { color: var(--text); }

    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .box {
      background: rgba(255,255,255,.05);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }
    input {
      background: rgba(0,0,0,.25);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 10px;
      color: var(--text);
      padding: 10px 12px;
      min-width: 220px;
      outline: none;
    }
    button.ctrl {
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.10);
      border-radius: 12px;
      padding: 10px 12px;
      font-weight: 700;
      cursor: pointer;
    }
    button.ctrl:hover { background: rgba(255,255,255,.09); }
    .hint { font-size: 13px; color: var(--muted); }

    .big {
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.03));
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      padding: 14px;
      box-shadow: 0 12px 30px var(--shadow);
    }
    .bigGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; }

    .small {
      position: relative;
      background: rgba(0,0,0,.15);
      border: 2px solid var(--grid);
      border-radius: 12px;
      padding: 10px;
      transition: transform .08s ease, border-color .12s ease, box-shadow .12s ease;
      user-select: none;
    }
    .small.active {
      border-color: rgba(255, 209, 102, .95);
      box-shadow: 0 0 0 3px rgba(255, 209, 102, .15);
      transform: translateY(-1px);
    }
    .small.free .badge {
      background: rgba(255, 209, 102, .15);
      border: 1px solid rgba(255, 209, 102, .35);
      color: var(--warn);
    }
    .badge {
      position: absolute;
      top: 8px;
      left: 8px;
      font-size: 12px;
      padding: 4px 7px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
    }
    .smallGrid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-top: 18px; }
    .cell {
      width: 100%;
      aspect-ratio: 1 / 1;
      border-radius: 10px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      color: var(--text);
      font-size: clamp(18px, 2.6vw, 28px);
      font-weight: 900;
      cursor: pointer;
      display: grid;
      place-items: center;
      transition: transform .06s ease, background .12s ease, border-color .12s ease;
    }
    .cell:hover { background: rgba(255,255,255,.08); transform: translateY(-1px); }
    .cell:disabled { cursor: not-allowed; opacity: .65; transform: none; }
    .cell.x { color: var(--x); }
    .cell.o { color: var(--o); }

    .overlay {
      position: absolute;
      inset: 0;
      border-radius: 12px;
      display: grid;
      place-items: center;
      font-weight: 1000;
      font-size: clamp(32px, 5vw, 58px);
      letter-spacing: 1px;
      background: rgba(0,0,0,.35);
      border: 2px solid rgba(255,255,255,.08);
      pointer-events: none;
      opacity: 0;
      transition: opacity .15s ease;
    }
    .overlay.show { opacity: 1; }
    .overlay.x { color: var(--x); }
    .overlay.o { color: var(--o); }
    .overlay.t { color: var(--muted); font-size: clamp(20px, 3.2vw, 34px); font-weight: 900; }

    .footer { color: var(--muted); font-size: 12px; text-align: center; padding-bottom: 4px; }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--muted);
      font-size: 12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="topbar">
      <h1 class="title">Ultimate Tic Tac Toe (online two-player)</h1>

      <div class="row">
        <div class="box">
          <button class="ctrl" id="createRoomBtn" type="button">Lag rom</button>
          <input id="roomInput" placeholder="Romkode (f.eks. ABCD)" maxlength="12" />
          <button class="ctrl" id="joinRoomBtn" type="button">Bli med</button>
          <button class="ctrl" id="copyLinkBtn" type="button">Kopier link</button>
          <span class="pill" id="roomPill">Ikke tilkoblet</span>
          <span class="pill" id="rolePill">Rolle: -</span>
        </div>
      </div>

      <p class="status" id="status"></p>
      <div class="row">
        <button class="ctrl" id="resetBtn" type="button">Nullstill (ny runde i samme rom)</button>
        <span class="hint">Tips: Send linken til en venn. Første som joiner blir X, neste blir O.</span>
      </div>
    </div>

    <div class="big">
      <div class="bigGrid" id="bigGrid"></div>
    </div>

    <div class="footer">
      Krever hosting (GitHub Pages) + Firebase Firestore for live synk.
    </div>
  </div>

  <!-- Firebase (modular SDK) -->
  <script type="module">
    // Flattener helpers
    function flattenBoards(boards) {
      return boards.flat();
    }

    function unflattenBoards(flat) {
      const out = [];
      for (let i = 0; i < 9; i++) {
        out.push(flat.slice(i * 9, i * 9 + 9));
      }
      return out;
    }

    // Firebase config (your own)
    const firebaseConfig = {
      apiKey: "AIzaSyCV0TRPv09RaAnYQP7jE43olIr_O77Iwm8",
      authDomain: "ultimate-tic-tac-toe-4bf73.firebaseapp.com",
      projectId: "ultimate-tic-tac-toe-4bf73",
      storageBucket: "ultimate-tic-tac-toe-4bf73.firebasestorage.app",
      messagingSenderId: "920364547136",
      appId: "1:920364547136:web:212997dc55347d64be33a5",
      measurementId: "G-65WQJKMEQB"
    };

    // === Importer Firebase ===
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js";
    import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js";
    import {
      getFirestore, doc, setDoc, getDoc, updateDoc, onSnapshot, serverTimestamp
    } from "https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js";

    // === UI refs ===
    const bigGridEl = document.getElementById("bigGrid");
    const statusEl = document.getElementById("status");
    const resetBtn = document.getElementById("resetBtn");
    const createRoomBtn = document.getElementById("createRoomBtn");
    const joinRoomBtn = document.getElementById("joinRoomBtn");
    const copyLinkBtn = document.getElementById("copyLinkBtn");
    const roomInput = document.getElementById("roomInput");
    const roomPill = document.getElementById("roomPill");
    const rolePill = document.getElementById("rolePill");

    // === Game state (lokalt speil av rommet) ===
    let roomId = null;
    let myUid = null;
    let myRole = null; // 'X' or 'O'
    let unsub = null;

    // data:
    let moveHistory; // liste med alle trekk
    let boards;
    let smallWinners;
    let currentPlayer;
    let activeBoard;
    let gameOver;

    // === Helpers ===
    function randRoomCode(len = 4) {
      const chars = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
      let out = "";
      for (let i = 0; i < len; i++) out += chars[Math.floor(Math.random() * chars.length)];
      return out;
    }

    function setStatus(html) { statusEl.innerHTML = html; }

    function emptyState() {
      boards = Array.from({ length: 9 }, () => Array(9).fill(""));
      smallWinners = Array(9).fill("");
      currentPlayer = "X";
      activeBoard = -1;
      gameOver = false;
      moveHistory = [];
    }

    function isBoardFinished(b) { return smallWinners[b] !== ""; }

    function checkWin3x3(arr) {
      const lines = [
        [0,1,2],[3,4,5],[6,7,8],
        [0,3,6],[1,4,7],[2,5,8],
        [0,4,8],[2,4,6]
      ];
      for (const [a,b,c] of lines) {
        if (arr[a] && arr[a] === arr[b] && arr[a] === arr[c]) return arr[a];
      }
      return "";
    }
    function checkTie3x3(arr) { return arr.every(v => v === "X" || v === "O"); }
    function getBigBoardAs3x3() {
      return smallWinners.map(w => (w === "X" || w === "O") ? w : "");
    }
    function checkBigWin() { return checkWin3x3(getBigBoardAs3x3()); }

    function cellClass(v) {
      if (v === "X") return "cell x";
      if (v === "O") return "cell o";
      return "cell";
    }

    function buildUI() {
      bigGridEl.innerHTML = "";
      for (let b = 0; b < 9; b++) {
        const small = document.createElement("div");
        small.className = "small";
        small.dataset.board = String(b);

        const badge = document.createElement("div");
        badge.className = "badge";
        badge.textContent = `Spill ${b + 1}`;
        small.appendChild(badge);

        const grid = document.createElement("div");
        grid.className = "smallGrid";

        for (let c = 0; c < 9; c++) {
          const btn = document.createElement("button");
          btn.type = "button";
          btn.className = "cell";
          btn.dataset.board = String(b);
          btn.dataset.cell = String(c);
          btn.addEventListener("click", onCellClick);
          grid.appendChild(btn);
        }

        small.appendChild(grid);

        const overlay = document.createElement("div");
        overlay.className = "overlay";
        overlay.dataset.overlay = String(b);
        small.appendChild(overlay);

        bigGridEl.appendChild(small);
      }
    }

    function updateUI() {
      // Hvis activeBoard peker på ferdig småspill => fri
      if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;

      // Oppdater brettet
      const smallEls = bigGridEl.querySelectorAll(".small");
      smallEls.forEach(small => {
        const b = Number(small.dataset.board);
        small.classList.remove("active", "free");

        if (activeBoard === -1) {
          if (!isBoardFinished(b)) small.classList.add("active", "free");
        } else {
          if (b === activeBoard) small.classList.add("active");
        }

        const btns = small.querySelectorAll(".cell");
        btns.forEach(btn => {
          const c = Number(btn.dataset.cell);
          const v = boards[b][c];
          btn.textContent = v;
          btn.className = cellClass(v);

          // disable hvis: ikke i rom, gameOver, tatt, småspill ferdig, ikke din tur, eller feil aktivt brett
          let disabled = false;
          if (!roomId || !myRole) disabled = true;
          if (gameOver) disabled = true;
          if (v) disabled = true;
          if (isBoardFinished(b)) disabled = true;

          const allowedByActive =
            (activeBoard === -1) ? (!isBoardFinished(b)) : (b === activeBoard);
          if (!allowedByActive) disabled = true;

          if (myRole !== currentPlayer) disabled = true;

          btn.disabled = disabled;
        });

        // overlay
        const overlay = small.querySelector(".overlay");
        const w = smallWinners[b];
        overlay.classList.remove("show", "x", "o", "t");
        overlay.textContent = "";
        if (w === "X" || w === "O") {
          overlay.classList.add("show", w.toLowerCase());
          overlay.textContent = w;
        } else if (w === "T") {
          overlay.classList.add("show", "t");
          overlay.textContent = "Uavgjort";
        }
      });

      // status
      if (!roomId) {
        setStatus(`Ikke tilkoblet. Trykk <b>Lag rom</b> eller <b>Bli med</b>.`);
        return;
      }
      if (!myRole) {
        setStatus(`Koblet til rom <b>${roomId}</b>. Venter på rolle...`);
        return;
      }

      const pSpan = (currentPlayer === "X")
        ? `<b style="color: var(--x)">X</b>`
        : `<b style="color: var(--o)">O</b>`;
      const meSpan = (myRole === "X")
        ? `<b style="color: var(--x)">X</b>`
        : `<b style="color: var(--o)">O</b>`;

      const nextInfo = (activeBoard === -1)
        ? "Neste trekk: <b>fri plassering</b> i et småspill som ikke er ferdig."
        : `Neste trekk må spilles i småspill <b>${activeBoard + 1}</b>.`;

      if (gameOver) {
        const win = checkBigWin();
        setStatus(`Spillet er ferdig. Vinner: <b>${win}</b>. (Du er ${meSpan})`);
      } else {
        const turnTxt = (myRole === currentPlayer)
          ? `Din tur (${meSpan}).`
          : `Motstander sin tur. (Du er ${meSpan})`;
        setStatus(`${turnTxt} Tur: ${pSpan}. ${nextInfo}`);
      }
    }

    // === Firebase setup ===
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);

    await signInAnonymously(auth);

    onAuthStateChanged(auth, (user) => {
      if (!user) return;
      myUid = user.uid;
      // auto-join via ?room=
      const params = new URLSearchParams(location.search);
      const qRoom = (params.get("room") || "").trim().toUpperCase();
      if (qRoom) {
        roomInput.value = qRoom;
        joinRoom(qRoom);
      }
    });

    function roomRef(id) { return doc(db, "rooms", id); }

    async function createRoom() {
      const id = randRoomCode(4);
      roomId = id;

      emptyState();
      const payload = {
        createdAt: serverTimestamp(),
        players: { x: myUid, o: null },
        state: {
          boards: flattenBoards(boards),
          smallWinners,
          currentPlayer,
          activeBoard,
          gameOver,
          move: 0,
          moveHistory: []
        }
      };
      await setDoc(roomRef(id), payload);
      await attachRoom(id);
      updateUrl(id);
      await claimRoleIfNeeded(); // should become X
    }

    async function joinRoom(id) {
      roomId = id;
      const snap = await getDoc(roomRef(id));
      if (!snap.exists()) {
        alert("Fant ikke rom. Sjekk koden.");
        roomId = null;
        return;
      }
      await attachRoom(id);
      updateUrl(id);
      await claimRoleIfNeeded();
    }

    function updateUrl(id) {
      const url = new URL(location.href);
      url.searchParams.set("room", id);
      history.replaceState({}, "", url.toString());
      roomPill.textContent = `Rom: ${id}`;
    }

    async function attachRoom(id) {
      if (unsub) unsub();
      roomPill.textContent = `Rom: ${id}`;

      unsub = onSnapshot(roomRef(id), (snap) => {
        const data = snap.data();
        if (!data) return;

        // role
        const px = data.players?.x || null;
        const po = data.players?.o || null;
        myRole = (myUid === px) ? "X" : (myUid === po) ? "O" : null;
        rolePill.textContent = `Rolle: ${myRole || "Spectator"}`;

        // state
        const st = data.state;
        if (st) {
          boards = unflattenBoards(st.boards);
          smallWinners = st.smallWinners;
          currentPlayer = st.currentPlayer;
          activeBoard = st.activeBoard;
          gameOver = st.gameOver;
          moveHistory = st.moveHistory || [];
        }

        updateUI();
      });
    }

    async function claimRoleIfNeeded() {
      if (!roomId) return;
      const ref = roomRef(roomId);
      const snap = await getDoc(ref);
      if (!snap.exists()) return;

      const data = snap.data();
      const px = data.players?.x || null;
      const po = data.players?.o || null;

      // If I'm already a player, done
      if (myUid === px || myUid === po) return;

      // Claim O if empty, else spectator
      if (!px) {
        await updateDoc(ref, { "players.x": myUid });
      } else if (!po) {
        await updateDoc(ref, { "players.o": myUid });
      } else {
        // already full
      }
    }

    // === Gameplay (writes to Firestore) ===
    async function onCellClick(e) {
      if (!roomId || !myRole) return;
      if (gameOver) return;
      if (myRole !== currentPlayer) return;

      const btn = e.currentTarget;
      const b = Number(btn.dataset.board);
      const c = Number(btn.dataset.cell);
      const moveNumber = (moveHistory?.length || 0) + 1;
      const newMove = { p: currentPlayer, b, c, n: moveNumber };
      moveHistory = [...(moveHistory || []), newMove];

      // enforce active board
      if (activeBoard !== -1 && b !== activeBoard) return;
      if (isBoardFinished(b)) return;
      if (boards[b][c]) return;

      // apply move locally
      boards[b][c] = currentPlayer;

      const smallWin = checkWin3x3(boards[b]);
      if (smallWin) smallWinners[b] = smallWin;
      else if (checkTie3x3(boards[b])) smallWinners[b] = "T";

      const bigWin = checkBigWin();
      if (bigWin) {
        gameOver = true;
      } else {
        activeBoard = c;
        if (activeBoard !== -1 && isBoardFinished(activeBoard)) activeBoard = -1;
        currentPlayer = (currentPlayer === "X") ? "O" : "X";
      }

      // push to firestore
      const ref = roomRef(roomId);
      // Note: for “skikkelig” konkurransesikkert burde man bruke transactions,
      // men dette funker bra for vanlig spilling.
      await updateDoc(ref, {
        "state.boards": flattenBoards(boards),
        "state.smallWinners": smallWinners,
        "state.currentPlayer": currentPlayer,
        "state.activeBoard": activeBoard,
        "state.gameOver": gameOver,
        "state.moveHistory": moveHistory,
        "state.move": (Number((await getDoc(ref)).data()?.state?.move || 0) + 1)
      });
    }

    async function resetRoundSameRoom() {
      if (!roomId) return;
      emptyState();
      await updateDoc(roomRef(roomId), {
        "state.boards": flattenBoards(boards),
        "state.smallWinners": smallWinners,
        "state.currentPlayer": currentPlayer,
        "state.activeBoard": activeBoard,
        "state.gameOver": gameOver,
        "state.moveHistory": [],
        "state.move": 0
      });
    }

    // === Buttons ===
    createRoomBtn.addEventListener("click", async () => {
      try { await createRoom(); }
      catch (err) { alert("Feil ved oppretting. Har du limt inn firebaseConfig?"); console.error(err); }
    });

    joinRoomBtn.addEventListener("click", async () => {
      const id = (roomInput.value || "").trim().toUpperCase();
      if (!id) return alert("Skriv inn romkode.");
      try { await joinRoom(id); }
      catch (err) { alert("Feil ved joining."); console.error(err); }
    });

    copyLinkBtn.addEventListener("click", async () => {
      if (!roomId) return alert("Lag/join et rom først.");
      const url = new URL(location.href);
      url.searchParams.set("room", roomId);
      try {
        await navigator.clipboard.writeText(url.toString());
        alert("Link kopiert!");
      } catch {
        prompt("Kopier denne linken:", url.toString());
      }
    });

    resetBtn.addEventListener("click", resetRoundSameRoom);

    // init UI
    emptyState();
    buildUI();
    updateUI();
  </script>
</body>
</html>
